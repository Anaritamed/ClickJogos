module Forca where

import Data.Map (Map)
import Data.Text (Text)
import Data.Char (toLower, toUpper, isSpace, isDigit)
import qualified Data.Map as Map
import System.Exit (exitSuccess)
import Control.Concurrent (threadDelay)
import Utils (limpaTerminal, coloreAmarelo, coloreVerde, bold)
import System.IO (hSetEcho, stdin, stdout, hFlush, getChar)


forca :: IO()
forca = do
    limpaTerminal
    putStrLn (unlines handleHomeForca)
    handleInteracaoInicial =<< getLine

handleInteracaoInicial :: String -> IO()
handleInteracaoInicial opcao
    | opcao == "1" = handleInteracaoInicialForca
    | opcao == "2" = do
        putStrLn "Saindo..."
        exitSuccess
    | otherwise = do
        putStrLn $ bold (coloreAmarelo "Op√ß√£o inv√°lida!")
        forca
            
handleInteracaoInicialForca :: IO()
handleInteracaoInicialForca = do
    let regras ="\nüìú Regras do jogo: \n" ++
                "\n- O jogador 1 ser√° o jogador que dir√° a palavra para ser adivinhada, assim como qual tema ela se relaciona.\n" ++
                "- O jogador 2 ser√° o jogador que tentar√° adivinhar a palavra dada pelo jogador 1.\n" ++
                "\n- Caso a palavra contenha uma letra acentuada ou √ß, digite exatamente a letra com sua acentua√ß√£o ou o √ß.\n" ++
                "- Por exemplo, caso a palavra fosse 'Ma√ß√£' a != √£, assim como c != √ß\n"
    putStrLn $ bold (coloreAmarelo regras)
    putStrLn "Digite o seu nome Jogador 1: "
    jogador1 <- getLine
    putStrLn "Digite o seu nome Jogador 2: "
    jogador2 <- getLine
    palavra <- loopGetLine jogador1
    putStrLn "Qual o tema que est√° relacionado √† palavra a ser adivinhada? "
    tema <- getLine
    jogo palavra tema

jogo :: String -> String -> IO ()
jogo palavra tema = do
    let mapaLetras = criaMapaLetras (map toLower palavra) -- Mapa de letras em min√∫sculas
    let estadoAtual = criaStringSublinhados palavra -- cria string sublinhada com o tamanho da palavra. Ex: ma√ß√£ ele criaria : _ _ _ _

    let loop stringSublinhada erros letrasDigitadas = do
            limpaTerminal
            atualizaForca erros -- printa forca vazia j√° que erros inicia em zero

            putStrLn $ bold (coloreAmarelo "\nTEMA: " ++ tema)
            putStrLn stringSublinhada
            putStrLn $ "\nLetras digitadas: " ++ letrasDigitadas
            putStrLn "\nDigite uma letra:"
            letraDigitada <- getLine
            
            if length letraDigitada > 1
                then do
                    putStrLn $ coloreAmarelo "\nAdivinhe com letra e n√£o palavras!"
                    loop stringSublinhada erros letrasDigitadas
                else do
                    let letra = toLower (head letraDigitada) -- Converte a letra digitada para min√∫scula
                    if letra `elem` letrasDigitadas
                        then do
                            putStrLn $ coloreAmarelo "\nEssa letra j√° foi digitada!\n"
                            threadDelay (900 * 1000) -- 0.9 segundos de delay
                            limpaTerminal
                            loop stringSublinhada erros letrasDigitadas
                        else do
                            let letrasDigitadasAtualizadas = letra : (" " ++ letrasDigitadas)
                            case Map.lookup letra mapaLetras of
                                Nothing -> do
                                    if (erros + 1) >= 6
                                        then do
                                            putStrLn (unlines $ handleCenarioPerda palavra)
                                            threadDelay (3 * 1000000) -- 2 segundos de delay
                                            forca
                                        else
                                            loop stringSublinhada (erros + 1) letrasDigitadasAtualizadas
                                Just indices -> do
                                    let novoEstadoStringSublinhados = atualizaStringSublinhados letra stringSublinhada indices
                                    if map toLower novoEstadoStringSublinhados == map toLower palavra
                                        then do
                                            putStrLn (unlines $ handleCenarioVitoria palavra)
                                            threadDelay (3 * 1000000) -- 2 segundos de delay
                                            forca
                                        else do
                                            loop novoEstadoStringSublinhados erros letrasDigitadasAtualizadas -- se ainda n√£o completou a palavra e n√£o errou o limite.
    loop estadoAtual 0 []

-- Fun√ß√£o que cria a string com sublinhados
criaStringSublinhados :: String -> String
criaStringSublinhados palavra = replicate (length palavra) '_'

-- Fun√ß√£o que cria um mapa de letra -> posi√ß√µes
criaMapaLetras :: String -> Map.Map Char [Int]
criaMapaLetras palavra =
    Map.fromListWith (++) [(letra, [i]) | (i, letra) <- zip [0..] palavra]

-- Fun√ß√£o para atualizar a string de sublinhados com a letra correta
atualizaStringSublinhados :: Char -> String -> [Int] -> String
atualizaStringSublinhados letra sublinhados indices =
    [if i `elem` indices then letra else sublinhados !! i | i <- [0..length sublinhados - 1]]

palavraValida :: String -> Bool
palavraValida palavra = not (null palavra) && not (all isSpace palavra) && not (any isDigit palavra)

loopGetLine :: String -> IO String
loopGetLine jogador1 = do
    putStrLn ("\nCerto " ++ bold jogador1 ++ ", qual a palavra da rodada? ")
    palavra <- hideInput
    if palavraValida palavra
        then return palavra
        else do
            putStrLn $ bold (coloreAmarelo "Palavra inv√°lida!")
            threadDelay (900 * 1000) -- 0.9 segundos de delay
            limpaTerminal
            loopGetLine jogador1

-- Fun√ß√£o para ocultar a entrada do usu√°rio e avan√ßar o prompt a cada letra digitada
hideInput :: IO String
hideInput = do
    hSetEcho stdin False  -- Desativa a exibi√ß√£o da entrada
    input <- loop ""
    hSetEcho stdin True   -- Reativa a exibi√ß√£o da entrada
    putStrLn ""           -- Move para a pr√≥xima linha ap√≥s a entrada
    return input
  where
    loop acc = do
        char <- getChar
        if char == '\n'
            then return (reverse acc)
            else do
                putChar '*'
                hFlush stdout
                loop (char : acc)

-- desenha a forca atualizada a cada erro (contado) passado
atualizaForca :: Int -> IO()
atualizaForca 0 = do
    putStrLn "      ________    \n"
    putStrLn "     |/       |   \n"
    putStrLn "     |        ¬ß   \n"
    putStrLn "     |            \n"
    putStrLn "     |            \n"
    putStrLn "     |            \n"
    putStrLn "   __|            \n"
    putStrLn "  |  |            \n"
    putStrLn "  ====             \n"
atualizaForca 1 = do
    putStrLn "      ________     \n"
    putStrLn "     |/       |    \n"
    putStrLn "     |        ¬ß    \n"
    putStrLn "     |      (*.*)  \n"
    putStrLn "     |             \n"
    putStrLn "     |             \n"
    putStrLn "   __|             \n"
    putStrLn "  |  |             \n"
    putStrLn "  ====             \n"
atualizaForca 2 = do
    putStrLn "      ________     \n"
    putStrLn "     |/       |    \n"
    putStrLn "     |        ¬ß    \n"
    putStrLn "     |      (*.*)  \n"
    putStrLn "     |        |    \n"
    putStrLn "     |       [ ]   \n"
    putStrLn "   __|        |    \n"
    putStrLn "  |  |             \n"
    putStrLn "  ====             \n"
atualizaForca 3 = do
    putStrLn "      ________     \n"
    putStrLn "     |/       |    \n"
    putStrLn "     |        ¬ß    \n"
    putStrLn "     |      (*.*)  \n"
    putStrLn "     |        |    \n"
    putStrLn "     |       [ ]   \n"
    putStrLn "   __|        |    \n"
    putStrLn "  |  |       /     \n"
    putStrLn "  ====             \n"
atualizaForca 4 = do
    putStrLn "      ________     \n"
    putStrLn "     |/       |    \n"
    putStrLn "     |        ¬ß    \n"
    putStrLn "     |      (*.*)  \n"
    putStrLn "     |        |    \n"
    putStrLn "     |       [ ]   \n"
    putStrLn "   __|        |    \n"
    putStrLn "  |  |       / \\  \n"
    putStrLn "  ====             \n"
atualizaForca 5 = do
    putStrLn "      ________     \n"
    putStrLn "     |/       |    \n"
    putStrLn "     |        ¬ß    \n"
    putStrLn "     |      (*.*)  \n"
    putStrLn "     |        |    \n"
    putStrLn "     |      /[ ]   \n"
    putStrLn "   __|        |    \n"
    putStrLn "  |  |       / \\  \n"
    putStrLn "  ====             \n"
atualizaForca 6 = do
    putStrLn "      ________     \n"
    putStrLn "     |/       |    \n"
    putStrLn "     |        ¬ß    \n"
    putStrLn "     |      (*.*)  \n"
    putStrLn "     |        |    \n"
    putStrLn "     |      /[ ]\\ \n"
    putStrLn "   __|        |    \n"
    putStrLn "  |  |       / \\  \n"
    putStrLn "  ====             \n"


handleHomeForca :: [String]
handleHomeForca =
           [ "                                               "
            ,"   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    "
            ,"   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó   "
            ,"   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   "
            ,"   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë   "
            ,"   ‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë   "
            ,"   ‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   "
            ,"               SEJA BEM VINDO!                 "
            ,"                                               "
            ,"                 (1) JOGAR                     "
            ,"              (2) SAIR DO JOGO                 "
            ,"                                               "]

handleCenarioPerda :: String -> [String]
handleCenarioPerda palavra =
                       [" ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó "
                       ,"‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó"
                       ,"‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù"
                       ,"‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó"
                       ,"‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë"
                       ," ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù"
                       ,"                           A PALAVRA ERA: " ++ map toUpper palavra ++ "!"]

handleCenarioVitoria :: String -> [String]
handleCenarioVitoria palavra =
    ["  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó"
    ," ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë"
    ," ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë"
    ," ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ïö‚ïê‚ïù"
    ," ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïó"
    ,"  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù    ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù"
    ,"                               PARAB√âNS, VOC√ä VENCEU! A PALAVRA ERA: " ++ map toUpper palavra ++ "!"]
