module Forca where

import Data.Map (Map)
import Data.Text (Text)
import Data.List (intercalate)
import Data.Char (toLower, toUpper, isSpace, isDigit)
import qualified Data.Map as Map
import System.Exit (exitSuccess)
import Control.Concurrent (threadDelay)
import System.IO (hSetEcho, stdin, stdout, hFlush, getChar)
import Utils (limpaTerminal, coloreAmarelo, coloreVerde, bold)

-- Fun√ß√£o inicial, que realiza o disparo do jogo forca
forca :: IO()
forca = do
    limpaTerminal
    putStrLn (unlines homeForca)
    menuForca =<< getLine

-- Menu de op√ß√µes do jogo forca
menuForca :: String -> IO()
menuForca opcao
    | opcao == "1" = processaDadosPartida
    | opcao == "2" = do
        putStrLn "Saindo..."
        exitSuccess
    | otherwise = do
        putStrLn $ bold (coloreAmarelo "Op√ß√£o inv√°lida!")
        forca

-- Processa dados da intera√ß√£o inicial com os usu√°rios
processaDadosPartida :: IO()
processaDadosPartida = do
    putStrLn $ bold (coloreAmarelo regrasDoJogo)
    putStrLn "Digite o seu nome Jogador 1: "
    jogador1 <- getLine
    putStrLn "Digite o seu nome Jogador 2: "
    jogador2 <- getLine
    putStrLn ("\nCerto " ++ bold jogador1 ++ " qual a palavra a ser adivinhada?")
    palavra <- loopGetCampoValido "palavra" "Palavra inv√°lida!"
    putStrLn "Qual o tema que est√° relacionado √† palavra a ser adivinhada? "
    tema <- loopGetCampoValido "tema" "Tema inv√°lido!"
    jogo palavra tema

-- L√≥gica principal do jogo
jogo :: String -> String -> IO ()
jogo palavra tema = do
    let mapaLetras = criaMapaLetras (map toLower palavra) -- Mapa de letras em min√∫sculas
    let estadoAtual = criaStringSublinhados palavra -- cria string sublinhada com o tamanho da palavra. Ex: ma√ß√£ ele criaria : _ _ _ _

    let loop stringSublinhada erros letrasDigitadas = do
            limpaTerminal
            putStrLn $ atualizaForca erros -- printa forca vazia j√° que erros inicia em zero

            putStrLn $ bold (coloreAmarelo "\nTEMA: " ++ tema)
            putStrLn stringSublinhada
            putStrLn $ "\nLetras digitadas: " ++ letrasDigitadas
            putStrLn "\nDigite uma letra:"
            letraDigitada <- loopGetCampoValido "letra" "Letra inv√°lida!"
            
            let letra = toLower (head letraDigitada) -- Converte a letra digitada para min√∫scula
            if letra `elem` letrasDigitadas
                then do
                    putStrLn $ coloreAmarelo "\nEssa letra j√° foi digitada!\n"
                    threadDelay (900 * 1000) -- 0.9 segundos de delay
                    limpaTerminal
                    loop stringSublinhada erros letrasDigitadas
                else do
                    let letrasDigitadasAtualizada = letra : (" " ++ letrasDigitadas)
                    case Map.lookup letra mapaLetras of
                        Nothing -> do
                            if (erros + 1) >= 6
                                then do
                                    putStrLn (unlines $ cenarioPerda palavra)
                                    threadDelay (3 * 1000000) -- 2 segundos de delay
                                    forca
                                else
                                    loop stringSublinhada (erros + 1) letrasDigitadasAtualizada
                        Just indices -> do
                            let novoEstadoStringSublinhados = atualizaStringSublinhados letra stringSublinhada indices
                            if map toLower novoEstadoStringSublinhados == map toLower palavra
                                then do
                                    putStrLn (unlines $ cenarioVitoria palavra)
                                    threadDelay (4 * 1000000) -- 4 segundos de delay
                                    forca
                                else do
                                    loop novoEstadoStringSublinhados erros letrasDigitadasAtualizada -- se ainda n√£o completou a palavra e n√£o errou o limite.
    loop estadoAtual 0 []

-- Fun√ß√£o que cria a string com sublinhados
criaStringSublinhados :: String -> String
criaStringSublinhados palavra = replicate (length palavra) '_'

-- Fun√ß√£o que cria um mapa de letra -> posi√ß√µes
criaMapaLetras :: String -> Map.Map Char [Int]
criaMapaLetras palavra =
    Map.fromListWith (++) [(letra, [i]) | (i, letra) <- zip [0..] palavra]

-- Fun√ß√£o para atualizar a string de sublinhados com a letra correta
atualizaStringSublinhados :: Char -> String -> [Int] -> String
atualizaStringSublinhados letra sublinhados indices =
    [if i `elem` indices then letra else sublinhados !! i | i <- [0..length sublinhados - 1]]

campoValido :: String -> Bool
campoValido campo = not (null campo) && not (all isSpace campo) && not (any isDigit campo)

-- Fun√ß√£o que requer em loop campo, caso n√£o validado corretamente
loopGetCampoValido :: String -> String -> IO String
loopGetCampoValido campo mensagem = do
    input <- getInput campo
    if isValid campo input
        then return input
        else do
            putStrLn $ bold (coloreAmarelo mensagem)
            loopGetCampoValido campo mensagem

-- Define formato em receber input, caso palavra ele esconde o input com a fun√ß√£o hideInput 
getInput :: String -> IO String
getInput "tema" = getLine
getInput "letra" = getLine
getInput "palavra" = hideInput

-- Realiza valida√ß√£o de acordo com o tipo de campo
isValid :: String -> String -> Bool
isValid "tema" input = campoValido input && length input > 1
isValid "letra" input = campoValido input && length input == 1
isValid "palavra" input = campoValido input && length input > 1 && notElem ' ' input

-- Fun√ß√£o para ocultar a entrada do usu√°rio e avan√ßar o prompt a cada letra digitada
hideInput :: IO String
hideInput = do
    hSetEcho stdin False  -- Desativa a exibi√ß√£o da entrada
    input <- loop ""
    hSetEcho stdin True   -- Reativa a exibi√ß√£o da entrada
    putStrLn ""           -- Move para a pr√≥xima linha ap√≥s a entrada
    return input
  where
    loop acc = do
        char <- getChar
        if char == '\n'
            then return (reverse acc)
            else do
                putChar '*'
                hFlush stdout
                loop (char : acc)

-- Desenha a forca atualizada a cada erro (contado) passado
atualizaForca :: Int -> String
atualizaForca 0 = intercalate "\n"
        [ "      ________    "
        , "     |/       |   "
        , "     |        ¬ß   "
        , "     |            "
        , "     |            "
        , "     |            "
        , "   __|            "
        , "  |  |            "
        , "  ====            "
        ]

atualizaForca 1 = intercalate "\n"
    [ "      ________     "
    , "     |/       |    "
    , "     |        ¬ß    "
    , "     |      (*.*)  "
    , "     |             "
    , "     |             "
    , "   __|             "
    , "  |  |             "
    , "  ====             "
    ]

atualizaForca 2 = intercalate "\n"
    [ "      ________     "
    , "     |/       |    "
    , "     |        ¬ß    "
    , "     |      (*.*)  "
    , "     |        |    "
    , "     |       [ ]   "
    , "   __|        |    "
    , "  |  |             "
    , "  ====             "
    ]

atualizaForca 3 = intercalate "\n"
    [ "      ________     "
    , "     |/       |    "
    , "     |        ¬ß    "
    , "     |      (*.*)  "
    , "     |        |    "
    , "     |       [ ]   "
    , "   __|        |    "
    , "  |  |       /     "
    , "  ====             "
    ]

atualizaForca 4 = intercalate "\n"
    [ "      ________     "
    , "     |/       |    "
    , "     |        ¬ß    "
    , "     |      (*.*)  "
    , "     |        |    "
    , "     |       [ ]   "
    , "   __|        |    "
    , "  |  |       / \\  "
    , "  ====             "
    ]

atualizaForca 5 = intercalate "\n"
    [ "      ________     "
    , "     |/       |    "
    , "     |        ¬ß    "
    , "     |      (*.*)  "
    , "     |        |    "
    , "     |      /[ ]   "
    , "   __|        |    "
    , "  |  |       / \\  "
    , "  ====             "
    ]

atualizaForca 6 = intercalate "\n"
    [ "      ________     "
    , "     |/       |    "
    , "     |        ¬ß    "
    , "     |      (*.*)  "
    , "     |        |    "
    , "     |      /[ ]\\ "
    , "   __|        |    "
    , "  |  |       / \\  "
    , "  ====             "
    ]

regrasDoJogo :: String
regrasDoJogo = intercalate "\n"
    [ "\nüìú Regras do jogo:                                                                                       "
    , "                                                                                                           "
    , "- O jogador 1 ser√° o jogador que dir√° a palavra para ser adivinhada, assim como qual tema ela se relaciona."
    , "- O jogador 2 ser√° o jogador que tentar√° adivinhar a palavra dada pelo jogador 1.                          "
    , "                                                                                                           "
    , "- Caso a palavra contenha uma letra acentuada ou √ß, digite exatamente a letra com sua acentua√ß√£o ou o √ß.   "
    , "- Por exemplo, caso a palavra fosse 'Ma√ß√£' a != √£, assim como c != √ß                                     \n"
    ]

homeForca :: [String]
homeForca =
           [ "                                               "
            ,"   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    "
            ,"   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó   "
            ,"   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   "
            ,"   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë   "
            ,"   ‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë   "
            ,"   ‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   "
            ,"               SEJA BEM VINDO!                 "
            ,"                                               "
            ,"                 (1) JOGAR                     "
            ,"              (2) SAIR DO JOGO                 "
            ,"                                               "]

cenarioPerda :: String -> [String]
cenarioPerda palavra =
                       [" ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó "
                       ,"‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó"
                       ,"‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù"
                       ,"‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó"
                       ,"‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó    ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë"
                       ," ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù"
                       ,"                           A PALAVRA ERA: " ++ bold (map toUpper palavra) ++ "!"]

cenarioVitoria :: String -> [String]
cenarioVitoria palavra =
    ["  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó"
    ," ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë"
    ," ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë"
    ," ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ïö‚ïê‚ïù"
    ," ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïó"
    ,"  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù    ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù"
    ,"                               PARAB√âNS, VOC√ä VENCEU! A PALAVRA ERA: " ++ bold (map toUpper palavra) ++ "!"]
